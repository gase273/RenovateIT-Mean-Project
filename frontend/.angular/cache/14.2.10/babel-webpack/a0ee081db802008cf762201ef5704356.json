{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\n\nconst rules_1 = require(\"../rules\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst errors_1 = require(\"../errors\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst util_1 = require(\"../util\");\n\nvar DataType;\n\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n\nfunction getSchemaTypes(schema) {\n  const types = getJSONTypes(schema.type);\n  const hasNull = types.includes(\"null\");\n\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n\n    if (schema.nullable === true) types.push(\"null\");\n  }\n\n  return types;\n}\n\nexports.getSchemaTypes = getSchemaTypes;\n\nfunction getJSONTypes(ts) {\n  const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\n\nexports.getJSONTypes = getJSONTypes;\n\nfunction coerceAndCheckDataType(it, types) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const coerceTo = coerceToTypes(types, opts.coerceTypes);\n  const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n\n  return checkTypes;\n}\n\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\n\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(t => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\n\nfunction coerceData(it, types, coerceTo) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const dataType = gen.let(\"dataType\", (0, codegen_1._)`typeof ${data}`);\n  const coerced = gen.let(\"coerced\", (0, codegen_1._)`undefined`);\n\n  if (opts.coerceTypes === \"array\") {\n    gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n  }\n\n  gen.if((0, codegen_1._)`${coerced} !== undefined`);\n\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n      coerceSpecificType(t);\n    }\n  }\n\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf((0, codegen_1._)`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, (0, codegen_1._)`\"\" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`\"\"`);\n        return;\n\n      case \"number\":\n        gen.elseIf((0, codegen_1._)`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);\n        return;\n\n      case \"integer\":\n        gen.elseIf((0, codegen_1._)`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);\n        return;\n\n      case \"boolean\":\n        gen.elseIf((0, codegen_1._)`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n        return;\n\n      case \"null\":\n        gen.elseIf((0, codegen_1._)`${data} === \"\" || ${data} === 0 || ${data} === false`);\n        gen.assign(coerced, null);\n        return;\n\n      case \"array\":\n        gen.elseIf((0, codegen_1._)`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);\n    }\n  }\n}\n\nfunction assignParentData({\n  gen,\n  parentData,\n  parentDataProperty\n}, expr) {\n  // TODO use gen.property\n  gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));\n}\n\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n  const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  let cond;\n\n  switch (dataType) {\n    case \"null\":\n      return (0, codegen_1._)`${data} ${EQ} null`;\n\n    case \"array\":\n      cond = (0, codegen_1._)`Array.isArray(${data})`;\n      break;\n\n    case \"object\":\n      cond = (0, codegen_1._)`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n      break;\n\n    case \"integer\":\n      cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);\n      break;\n\n    case \"number\":\n      cond = numCond();\n      break;\n\n    default:\n      return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;\n  }\n\n  return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n\n  function numCond(_cond = codegen_1.nil) {\n    return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);\n  }\n}\n\nexports.checkDataType = checkDataType;\n\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n\n  let cond;\n  const types = (0, util_1.toHash)(dataTypes);\n\n  if (types.array && types.object) {\n    const notObj = (0, codegen_1._)`typeof ${data} != \"object\"`;\n    cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n\n  if (types.number) delete types.integer;\n\n  for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n\n  return cond;\n}\n\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n  message: ({\n    schema\n  }) => `must be ${schema}`,\n  params: ({\n    schema,\n    schemaValue\n  }) => typeof schema == \"string\" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`\n};\n\nfunction reportTypeError(it) {\n  const cxt = getTypeErrorContext(it);\n  (0, errors_1.reportError)(cxt, typeError);\n}\n\nexports.reportTypeError = reportTypeError;\n\nfunction getTypeErrorContext(it) {\n  const {\n    gen,\n    data,\n    schema\n  } = it;\n  const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","reportTypeError","checkDataTypes","checkDataType","coerceAndCheckDataType","getJSONTypes","getSchemaTypes","DataType","rules_1","require","applicability_1","errors_1","codegen_1","util_1","schema","types","type","hasNull","includes","nullable","Error","length","undefined","push","ts","Array","isArray","every","isJSONType","join","it","gen","data","opts","coerceTo","coerceToTypes","coerceTypes","checkTypes","schemaHasRulesForType","wrongType","strictNumbers","Wrong","if","coerceData","COERCIBLE","Set","filter","t","has","dataType","let","_","coerced","assign","coerceSpecificType","else","endIf","assignParentData","elseIf","parentData","parentDataProperty","expr","strictNums","correct","Correct","EQ","operators","NEQ","cond","numCond","not","_cond","nil","and","dataTypes","toHash","array","object","notObj","null","number","integer","typeError","message","params","schemaValue","cxt","getTypeErrorContext","reportError","schemaCode","schemaRefOrVal","keyword","parentSchema"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/compile/validate/dataType.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}