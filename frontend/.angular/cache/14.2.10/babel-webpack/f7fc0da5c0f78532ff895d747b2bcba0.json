{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst types_1 = require(\"../discriminator/types\");\n\nconst compile_1 = require(\"../../compile\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: ({\n    params: {\n      discrError,\n      tagName\n    }\n  }) => discrError === types_1.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({\n    params: {\n      discrError,\n      tag,\n      tagName\n    }\n  }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`\n};\nconst def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      oneOf\n    } = parentSchema;\n\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n\n    const tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    const valid = gen.let(\"valid\", false);\n    const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);\n    gen.if((0, codegen_1._)`typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, {\n      discrError: types_1.DiscrError.Tag,\n      tag,\n      tagName\n    }));\n    cxt.ok(valid);\n\n    function validateMapping() {\n      const mapping = getMapping();\n      gen.if(false);\n\n      for (const tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag,\n        tagName\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n\n      const schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n\n    function getMapping() {\n      var _a;\n\n      const oneOfMapping = {};\n      const topRequired = hasRequired(parentSchema);\n      let tagRequired = true;\n\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i];\n\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n        }\n\n        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n\n        if (typeof propSch != \"object\") {\n          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n        }\n\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`);\n      return oneOfMapping;\n\n      function hasRequired({\n        required\n      }) {\n        return Array.isArray(required) && required.includes(tagName);\n      }\n\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i);\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n        }\n      }\n\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n        }\n\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","types_1","compile_1","util_1","error","message","params","discrError","tagName","DiscrError","Tag","tag","_","def","keyword","type","schemaType","code","cxt","gen","data","schema","parentSchema","it","oneOf","opts","discriminator","Error","propertyName","mapping","valid","let","const","getProperty","if","validateMapping","ok","getMapping","tagValue","elseIf","assign","applyTagSchema","else","Mapping","endIf","schemaProp","_valid","name","schCxt","subschema","mergeEvaluated","Name","_a","oneOfMapping","topRequired","hasRequired","tagRequired","i","length","sch","$ref","schemaHasRulesButRef","self","RULES","resolveRef","call","schemaEnv","root","baseId","SchemaEnv","propSch","properties","addMappings","required","Array","isArray","includes","addMapping","enum","default"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/vocabularies/discriminator/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}