{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst equal = require(\"fast-deep-equal\");\n\nconst traverse = require(\"json-schema-traverse\"); // TODO refactor to use keyword definitions\n\n\nconst SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\n\nfunction inlineRef(schema, limit = true) {\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\n\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\n\nfunction hasRef(schema) {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    const sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n\n  return false;\n}\n\nfunction countKeys(schema) {\n  let count = 0;\n\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], sch => count += countKeys(sch));\n    }\n\n    if (count === Infinity) return Infinity;\n  }\n\n  return count;\n}\n\nfunction getFullPath(resolver, id = \"\", normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  const p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\n\nexports.getFullPath = getFullPath;\n\nfunction _getFullPath(resolver, p) {\n  const serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\n\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\n\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\n\nexports.normalizeId = normalizeId;\n\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\n\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n\nfunction getSchemaRefs(schema, baseId) {\n  if (typeof schema == \"boolean\") return {};\n  const {\n    schemaId,\n    uriResolver\n  } = this.opts;\n  const schId = normalizeId(schema[schemaId] || baseId);\n  const baseIds = {\n    \"\": schId\n  };\n  const pathPrefix = getFullPath(uriResolver, schId, false);\n  const localRefs = {};\n  const schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return;\n    const fullPath = pathPrefix + jsonPtr;\n    let baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId]);\n    addAnchor.call(this, sch.$anchor);\n    addAnchor.call(this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      let schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n\n      return ref;\n    }\n\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n        addRef.call(this, `#${anchor}`);\n      }\n    }\n  });\n  return localRefs;\n\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n\n  function ambiguos(ref) {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`);\n  }\n}\n\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSchemaRefs","resolveUrl","normalizeId","_getFullPath","getFullPath","inlineRef","util_1","require","equal","traverse","SIMPLE_INLINED","Set","schema","limit","hasRef","countKeys","REF_KEYWORDS","key","has","sch","Array","isArray","some","count","Infinity","eachItem","resolver","id","normalize","p","parse","serialized","serialize","split","TRAILING_SLASH_HASH","replace","baseId","resolve","ANCHOR","schemaId","uriResolver","opts","schId","baseIds","pathPrefix","localRefs","schemaRefs","allKeys","jsonPtr","_","parentJsonPtr","undefined","fullPath","addRef","call","addAnchor","$anchor","$dynamicAnchor","ref","_resolve","ambiguos","add","schOrRef","refs","checkAmbiguosRef","anchor","test","Error","sch1","sch2"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/compile/resolve.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}