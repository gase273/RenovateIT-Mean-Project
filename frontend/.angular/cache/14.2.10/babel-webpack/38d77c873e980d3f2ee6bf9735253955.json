{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\n\nconst boolSchema_1 = require(\"./boolSchema\");\n\nconst dataType_1 = require(\"./dataType\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst dataType_2 = require(\"./dataType\");\n\nconst defaults_1 = require(\"./defaults\");\n\nconst keyword_1 = require(\"./keyword\");\n\nconst subschema_1 = require(\"./subschema\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst resolve_1 = require(\"../resolve\");\n\nconst util_1 = require(\"../util\");\n\nconst errors_1 = require(\"../errors\"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas\n\n\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n\n  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\n\nexports.validateFunctionCode = validateFunctionCode;\n\nfunction validateFunction({\n  gen,\n  validateName,\n  schema,\n  schemaEnv,\n  opts\n}, body) {\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code((0, codegen_1._)`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\n\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\n\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`\"\"`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);\n  });\n}\n\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\n\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)`${validateName}.evaluated`);\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));\n}\n\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;\n} // schema compilation - this function is used recursively to generate code for sub-schemas\n\n\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\n\nfunction schemaCxtHasRules({\n  schema,\n  self\n}) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (self.RULES.all[key]) return true;\n\n  return false;\n}\n\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\n\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount); // TODO var\n\n  gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n}\n\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\n\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = (0, dataType_1.getSchemaTypes)(it.schema);\n  const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\n\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\n\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\n\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\n\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\n\nfunction commentKeyword({\n  gen,\n  schemaEnv,\n  schema,\n  errSchemaPath,\n  opts\n}) {\n  const msg = schema.$comment;\n\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\n\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);\n  }\n}\n\nfunction assignEvaluated({\n  gen,\n  evaluated,\n  props,\n  items\n}) {\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);\n}\n\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n\n    return;\n  }\n\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n\n    groupKeywords(RULES.post);\n  });\n\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    } // TODO make it \"ok\" call?\n\n\n    if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\n\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\n\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\n\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  narrowSchemaTypes(it, types);\n}\n\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\n\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\n\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\n\nfunction narrowSchemaTypes(it, withTypes) {\n  const ts = [];\n\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t);else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\");\n  }\n\n  it.dataTypes = ts;\n}\n\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\n\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n\n  result(condition, successAction, failAction) {\n    this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n  }\n\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n\n  pass(condition, failAction) {\n    this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n  }\n\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n\n      return;\n    }\n\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n  }\n\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n\n      this._error(append, errorPaths);\n\n      this.setParams({});\n      return;\n    }\n\n    this._error(append, errorPaths);\n  }\n\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n\n  $dataError() {\n    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n  }\n\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n\n  block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n\n  check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n\n    gen.else();\n  }\n\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n      }\n\n      return codegen_1.nil;\n    }\n\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n\n        return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;\n      }\n\n      return codegen_1.nil;\n    }\n  }\n\n  subschema(appl, valid) {\n    const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n    (0, subschema_1.extendSubschemaMode)(subschema, appl);\n    const nextContext = { ...this.it,\n      ...subschema,\n      items: undefined,\n      props: undefined\n    };\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n\n}\n\nexports.KeywordCxt = KeywordCxt;\n\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n\nfunction getData($data, {\n  dataLevel,\n  dataNames,\n  dataPathArr\n}) {\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n\n  for (const segment of segments) {\n    if (segment) {\n      data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n      expr = (0, codegen_1._)`${expr} && ${data}`;\n    }\n  }\n\n  return expr;\n\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\n\nexports.getData = getData;","map":{"version":3,"names":["Object","defineProperty","exports","value","getData","KeywordCxt","validateFunctionCode","boolSchema_1","require","dataType_1","applicability_1","dataType_2","defaults_1","keyword_1","subschema_1","codegen_1","names_1","resolve_1","util_1","errors_1","it","isSchemaObj","checkKeywords","schemaCxtHasRules","topSchemaObjCode","validateFunction","topBoolOrEmptySchema","gen","validateName","schema","schemaEnv","opts","body","code","es5","func","_","default","data","valCxt","$async","funcSourceUrl","destructureValCxtES5","destructureValCxt","instancePath","parentData","parentDataProperty","rootData","dynamicRef","dynamicAnchors","nil","if","var","$comment","commentKeyword","checkNoDefault","let","vErrors","errors","unevaluated","resetEvaluated","typeAndKeywords","returnResults","evaluated","const","assign","schId","schemaId","source","process","subschemaCode","valid","subSchemaObjCode","boolOrEmptySchema","self","key","RULES","all","updateContext","checkAsyncSchema","errsCount","checkUnknownRules","checkRefsAndKeywords","jtd","schemaKeywords","types","getSchemaTypes","checkedTypes","coerceAndCheckDataType","errSchemaPath","$ref","ignoreKeywordsWithRef","schemaHasRulesButRef","logger","warn","undefined","useDefaults","strictSchema","checkStrictMode","baseId","resolveUrl","uriResolver","Error","msg","schemaPath","str","rootName","scopeValue","ref","root","ValidationError","return","throw","assignEvaluated","props","items","Name","typeErrors","allErrors","block","keywordCode","definition","checkStrictTypes","group","rules","groupKeywords","post","shouldUseGroup","type","checkDataType","strictNumbers","iterateKeywords","length","else","reportTypeError","endIf","assignDefaults","rule","shouldUseRule","keyword","meta","strictTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","checkKeywordTypes","dataTypes","forEach","t","includesType","strictTypesError","join","narrowSchemaTypes","ts","includes","some","hasApplicableType","schTs","kwdT","withTypes","push","constructor","def","validateKeywordUsage","$data","schemaValue","schemaRefOrVal","schemaType","parentSchema","params","schemaCode","validSchemaType","allowUndefined","JSON","stringify","trackErrors","result","condition","successAction","failAction","failResult","not","error","pass","fail","fail$data","or","invalid$data","append","errorParams","errorPaths","setParams","_error","reportExtraError","reportError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","cond","obj","block$data","codeBlock","$dataValid","check$data","validateSchema","elseIf","wrong$DataType","invalid$DataSchema","st","Array","isArray","checkDataTypes","DataType","Wrong","validateSchemaRef","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeEvaluated","schemaCxt","toName","mergeValidEvaluated","ruleType","cxt","validate","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","jsonPointer","test","matches","exec","up","errorMsg","expr","segments","split","segment","getProperty","unescapeJsonPointer","pointerType"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/compile/validate/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}