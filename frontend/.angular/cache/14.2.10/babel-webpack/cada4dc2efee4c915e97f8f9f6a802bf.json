{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst util_2 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","code_1","require","codegen_1","util_1","util_2","def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","allSchemaProperties","alwaysValidPatterns","filter","p","alwaysValidSchema","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","Name","evaluatedPropsToName","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","checkStrictMode","forIn","key","_","usePattern","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","Type","Str","assign","not","break","default"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}