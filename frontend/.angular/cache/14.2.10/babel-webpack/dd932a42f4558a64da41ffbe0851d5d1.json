{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: ({\n    params\n  }) => (0, codegen_1.str)`must match \"${params.ifClause}\" schema`,\n  params: ({\n    params\n  }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`\n};\nconst def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      parentSchema,\n      it\n    } = cxt;\n\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n\n    const hasThen = hasSchema(it, \"then\");\n    const hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    const valid = gen.let(\"valid\", true);\n    const schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n\n    cxt.pass(valid, () => cxt.error(true));\n\n    function validateIf() {\n      const schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n\n    function validateClause(keyword, ifClause) {\n      return () => {\n        const schCxt = cxt.subschema({\n          keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n\n};\n\nfunction hasSchema(it, keyword) {\n  const schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\n\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","util_1","error","message","params","str","ifClause","_","def","keyword","schemaType","trackErrors","code","cxt","gen","parentSchema","it","then","undefined","else","checkStrictMode","hasThen","hasSchema","hasElse","valid","let","schValid","name","validateIf","reset","setParams","if","validateClause","not","pass","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","assign","mergeValidEvaluated","schema","alwaysValidSchema","default"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/vocabularies/applicator/if.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}