{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\n\nvar validate_1 = require(\"./compile/validate\");\n\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\n\nvar codegen_1 = require(\"./compile/codegen\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});\n\nconst validation_error_1 = require(\"./runtime/validation_error\");\n\nconst ref_error_1 = require(\"./compile/ref_error\");\n\nconst rules_1 = require(\"./compile/rules\");\n\nconst compile_1 = require(\"./compile\");\n\nconst codegen_2 = require(\"./compile/codegen\");\n\nconst resolve_1 = require(\"./compile/resolve\");\n\nconst dataType_1 = require(\"./compile/validate/dataType\");\n\nconst util_1 = require(\"./compile/util\");\n\nconst $dataRefSchema = require(\"./refs/data.json\");\n\nconst uri_1 = require(\"./runtime/uri\");\n\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\n\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nconst removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nconst deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst MAX_EXPRESSION = 200; // eslint-disable-next-line complexity\n\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n\n  const s = o.strict;\n\n  const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? { ...o.code,\n      optimize,\n      regExp\n    } : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\n\nclass Ajv {\n  constructor(opts = {}) {\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = { ...opts,\n      ...requiredOptions(opts)\n    };\n    const {\n      es5,\n      lines\n    } = this.opts.code;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    const formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n\n    this._addVocabularies();\n\n    this._addDefaultMetaSchema();\n\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n\n  _addDefaultMetaSchema() {\n    const {\n      $data,\n      meta,\n      schemaId\n    } = this.opts;\n    let _dataRefSchema = $dataRefSchema;\n\n    if (schemaId === \"id\") {\n      _dataRefSchema = { ...$dataRefSchema\n      };\n      _dataRefSchema.id = _dataRefSchema.$id;\n      delete _dataRefSchema.$id;\n    }\n\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n  }\n\n  defaultMeta() {\n    const {\n      meta,\n      schemaId\n    } = this.opts;\n    return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n  }\n\n  validate(schemaKeyRef, // key, ref or schema object\n  data // to be validated\n  ) {\n    let v;\n\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n    } else {\n      v = this.compile(schemaKeyRef);\n    }\n\n    const valid = v(data);\n    if (!(\"$async\" in v)) this.errors = v.errors;\n    return valid;\n  }\n\n  compile(schema, _meta) {\n    const sch = this._addSchema(schema, _meta);\n\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n\n  compileAsync(schema, meta) {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\");\n    }\n\n    const {\n      loadSchema\n    } = this.opts;\n    return runCompileAsync.call(this, schema, meta);\n\n    function runCompileAsync(_x2, _x3) {\n      return _runCompileAsync.apply(this, arguments);\n    }\n\n    function _runCompileAsync() {\n      _runCompileAsync = _asyncToGenerator(function* (_schema, _meta) {\n        yield loadMetaSchema.call(this, _schema.$schema);\n\n        const sch = this._addSchema(_schema, _meta);\n\n        return sch.validate || _compileAsync.call(this, sch);\n      });\n      return _runCompileAsync.apply(this, arguments);\n    }\n\n    function loadMetaSchema(_x4) {\n      return _loadMetaSchema.apply(this, arguments);\n    }\n\n    function _loadMetaSchema() {\n      _loadMetaSchema = _asyncToGenerator(function* ($ref) {\n        if ($ref && !this.getSchema($ref)) {\n          yield runCompileAsync.call(this, {\n            $ref\n          }, true);\n        }\n      });\n      return _loadMetaSchema.apply(this, arguments);\n    }\n\n    function _compileAsync(_x5) {\n      return _compileAsync2.apply(this, arguments);\n    }\n\n    function _compileAsync2() {\n      _compileAsync2 = _asyncToGenerator(function* (sch) {\n        try {\n          return this._compileSchemaEnv(sch);\n        } catch (e) {\n          if (!(e instanceof ref_error_1.default)) throw e;\n          checkLoaded.call(this, e);\n          yield loadMissingSchema.call(this, e.missingSchema);\n          return _compileAsync.call(this, sch);\n        }\n      });\n      return _compileAsync2.apply(this, arguments);\n    }\n\n    function checkLoaded({\n      missingSchema: ref,\n      missingRef\n    }) {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n      }\n    }\n\n    function loadMissingSchema(_x6) {\n      return _loadMissingSchema.apply(this, arguments);\n    }\n\n    function _loadMissingSchema() {\n      _loadMissingSchema = _asyncToGenerator(function* (ref) {\n        const _schema = yield _loadSchema.call(this, ref);\n\n        if (!this.refs[ref]) yield loadMetaSchema.call(this, _schema.$schema);\n        if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n      });\n      return _loadMissingSchema.apply(this, arguments);\n    }\n\n    function _loadSchema(_x7) {\n      return _loadSchema2.apply(this, arguments);\n    }\n\n    function _loadSchema2() {\n      _loadSchema2 = _asyncToGenerator(function* (ref) {\n        const p = this._loading[ref];\n        if (p) return p;\n\n        try {\n          return yield this._loading[ref] = loadSchema(ref);\n        } finally {\n          delete this._loading[ref];\n        }\n      });\n      return _loadSchema2.apply(this, arguments);\n    }\n  } // Adds schema to the instance\n\n\n  addSchema(schema, // If array is passed, `key` will be ignored\n  key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n  _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n  _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ) {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);\n\n      return this;\n    }\n\n    let id;\n\n    if (typeof schema === \"object\") {\n      const {\n        schemaId\n      } = this.opts;\n      id = schema[schemaId];\n\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`);\n      }\n    }\n\n    key = (0, resolve_1.normalizeId)(key || id);\n\n    this._checkUnique(key);\n\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n    return this;\n  } // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n\n\n  addMetaSchema(schema, key, // schema key\n  _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ) {\n    this.addSchema(schema, key, true, _validateSchema);\n    return this;\n  } //  Validate schema against its meta-schema\n\n\n  validateSchema(schema, throwOrLogError) {\n    if (typeof schema == \"boolean\") return true;\n    let $schema;\n    $schema = schema.$schema;\n\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\");\n    }\n\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n\n    const valid = this.validate($schema, schema);\n\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText();\n      if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n    }\n\n    return valid;\n  } // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n\n\n  getSchema(keyRef) {\n    let sch;\n\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch;\n\n    if (sch === undefined) {\n      const {\n        schemaId\n      } = this.opts;\n      const root = new compile_1.SchemaEnv({\n        schema: {},\n        schemaId\n      });\n      sch = compile_1.resolveSchema.call(this, root, keyRef);\n      if (!sch) return;\n      this.refs[keyRef] = sch;\n    }\n\n    return sch.validate || this._compileSchemaEnv(sch);\n  } // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n\n\n  removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef);\n\n      this._removeAllSchemas(this.refs, schemaKeyRef);\n\n      return this;\n    }\n\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n\n        this._removeAllSchemas(this.refs);\n\n        this._cache.clear();\n\n        return this;\n\n      case \"string\":\n        {\n          const sch = getSchEnv.call(this, schemaKeyRef);\n          if (typeof sch == \"object\") this._cache.delete(sch.schema);\n          delete this.schemas[schemaKeyRef];\n          delete this.refs[schemaKeyRef];\n          return this;\n        }\n\n      case \"object\":\n        {\n          const cacheKey = schemaKeyRef;\n\n          this._cache.delete(cacheKey);\n\n          let id = schemaKeyRef[this.opts.schemaId];\n\n          if (id) {\n            id = (0, resolve_1.normalizeId)(id);\n            delete this.schemas[id];\n            delete this.refs[id];\n          }\n\n          return this;\n        }\n\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  } // add \"vocabulary\" - a collection of keywords\n\n\n  addVocabulary(definitions) {\n    for (const def of definitions) this.addKeyword(def);\n\n    return this;\n  }\n\n  addKeyword(kwdOrDef, def // deprecated\n  ) {\n    let keyword;\n\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef;\n\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n        def.keyword = keyword;\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef;\n      keyword = def.keyword;\n\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\");\n    }\n\n    checkKeyword.call(this, keyword, def);\n\n    if (!def) {\n      (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd));\n      return this;\n    }\n\n    keywordMetaschema.call(this, def);\n    const definition = { ...def,\n      type: (0, dataType_1.getJSONTypes)(def.type),\n      schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n    };\n    (0, util_1.eachItem)(keyword, definition.type.length === 0 ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t)));\n    return this;\n  }\n\n  getKeyword(keyword) {\n    const rule = this.RULES.all[keyword];\n    return typeof rule == \"object\" ? rule.definition : !!rule;\n  } // Remove keyword\n\n\n  removeKeyword(keyword) {\n    // TODO return type should be Ajv\n    const {\n      RULES\n    } = this;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex(rule => rule.keyword === keyword);\n      if (i >= 0) group.rules.splice(i, 1);\n    }\n\n    return this;\n  } // Add format\n\n\n  addFormat(name, format) {\n    if (typeof format == \"string\") format = new RegExp(format);\n    this.formats[name] = format;\n    return this;\n  }\n\n  errorsText(errors = this.errors, // optional array of validation errors\n  {\n    separator = \", \",\n    dataVar = \"data\"\n  } = {} // optional options with properties `separator` and `dataVar`\n  ) {\n    if (!errors || errors.length === 0) return \"No errors\";\n    return errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n  }\n\n  $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n    const rules = this.RULES.all;\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n\n      let keywords = metaSchema;\n\n      for (const seg of segments) keywords = keywords[seg];\n\n      for (const key in rules) {\n        const rule = rules[key];\n        if (typeof rule != \"object\") continue;\n        const {\n          $data\n        } = rule.definition;\n        const schema = keywords[key];\n        if ($data && schema) keywords[key] = schemaOrData(schema);\n      }\n    }\n\n    return metaSchema;\n  }\n\n  _removeAllSchemas(schemas, regex) {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef];\n\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef];\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema);\n\n          delete schemas[keyRef];\n        }\n      }\n    }\n  }\n\n  _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n    let id;\n    const {\n      schemaId\n    } = this.opts;\n\n    if (typeof schema == \"object\") {\n      id = schema[schemaId];\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n    }\n\n    let sch = this._cache.get(schema);\n\n    if (sch !== undefined) return sch;\n    baseId = (0, resolve_1.normalizeId)(id || baseId);\n    const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n    sch = new compile_1.SchemaEnv({\n      schema,\n      schemaId,\n      meta,\n      baseId,\n      localRefs\n    });\n\n    this._cache.set(sch.schema, sch);\n\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId);\n      this.refs[baseId] = sch;\n    }\n\n    if (validateSchema) this.validateSchema(schema, true);\n    return sch;\n  }\n\n  _checkUnique(id) {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n  }\n\n  _compileSchemaEnv(sch) {\n    if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n    /* istanbul ignore if */\n\n    if (!sch.validate) throw new Error(\"ajv implementation error\");\n    return sch.validate;\n  }\n\n  _compileMetaSchema(sch) {\n    const currentOpts = this.opts;\n    this.opts = this._metaOpts;\n\n    try {\n      compile_1.compileSchema.call(this, sch);\n    } finally {\n      this.opts = currentOpts;\n    }\n  }\n\n}\n\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\n\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n  for (const key in checkOpts) {\n    const opt = key;\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n  }\n}\n\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\n\nfunction addInitialSchemas() {\n  const optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);\n}\n\nfunction addInitialFormats() {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\n\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n\n  for (const keyword in defs) {\n    const def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\n\nfunction getMetaSchemaOptions() {\n  const metaOpts = { ...this.opts\n  };\n\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];\n\n  return metaOpts;\n}\n\nconst noLogs = {\n  log() {},\n\n  warn() {},\n\n  error() {}\n\n};\n\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\n\nfunction checkKeyword(keyword, def) {\n  const {\n    RULES\n  } = this;\n  (0, util_1.eachItem)(keyword, kwd => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n  });\n  if (!def) return;\n\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\n\nfunction addRule(keyword, definition, dataType) {\n  var _a;\n\n  const post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES\n  } = this;\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({\n    type: t\n  }) => t === dataType);\n\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  const rule = {\n    keyword,\n    definition: { ...definition,\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    }\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(kwd => this.addKeyword(kwd));\n}\n\nfunction addBeforeRule(ruleGroup, rule, before) {\n  const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);\n\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(`rule ${before} is not defined`);\n  }\n}\n\nfunction keywordMetaschema(def) {\n  let {\n    metaSchema\n  } = def;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\n\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","CodeGen","Name","nil","stringify","str","_","KeywordCxt","validate_1","require","enumerable","get","codegen_1","validation_error_1","ref_error_1","rules_1","compile_1","codegen_2","resolve_1","dataType_1","util_1","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","code","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","Set","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","MAX_EXPRESSION","requiredOptions","o","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","_0","s","strict","_optz","optimize","undefined","regExp","uriResolver","default","strictSchema","strictNumbers","strictTypes","strictTuples","strictRequired","loopRequired","loopEnum","meta","messages","inlineRefs","schemaId","addUsedSchema","validateSchema","validateFormats","unicodeRegExp","int32range","Ajv","constructor","opts","schemas","refs","formats","_compilations","_loading","_cache","Map","es5","lines","scope","ValueScope","prefixes","logger","getLogger","formatOpt","RULES","getRules","checkOptions","call","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","id","$id","defaultMeta","validate","schemaKeyRef","data","v","getSchema","Error","compile","valid","errors","schema","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","$ref","e","checkLoaded","loadMissingSchema","missingSchema","ref","missingRef","_loadSchema","addSchema","p","key","_validateSchema","Array","isArray","normalizeId","_checkUnique","throwOrLogError","warn","message","errorsText","error","keyRef","getSchEnv","root","SchemaEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","cacheKey","addVocabulary","definitions","def","kwdOrDef","keyword","length","checkKeyword","eachItem","kwd","addRule","keywordMetaschema","definition","type","getJSONTypes","schemaType","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","msg","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","jsonPointer","segments","split","slice","seg","schemaOrData","regex","test","baseId","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","ValidationError","MissingRefError","checkOpts","options","log","opt","optsSchemas","defs","metaOpts","noLogs","console","KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/core.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}