{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst errors_1 = require(\"../errors\");\n\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\n\nexports.macroKeywordCode = macroKeywordCode;\n\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)`await `), e => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n\n  function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n\n  function reportErrs(errors) {\n    var _a;\n\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\n\nexports.funcKeywordCode = funcKeywordCode;\n\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n}\n\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\n\nfunction checkAsyncKeyword({\n  schemaEnv\n}, def) {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\n\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\n\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\n\nexports.validSchemaType = validSchemaType;\n\nfunction validateKeywordUsage({\n  schema,\n  opts,\n  self,\n  errSchemaPath\n}, def, keyword) {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n\n  const deps = def.dependencies;\n\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\n\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateKeywordUsage","validSchemaType","funcKeywordCode","macroKeywordCode","codegen_1","require","names_1","code_1","errors_1","cxt","def","gen","keyword","schema","parentSchema","it","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","nil","errSchemaPath","topSchemaRef","compositeRule","pass","error","_a","$data","checkAsyncKeyword","validate","compile","validateRef","let","block$data","validateKeyword","ok","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","_","e","assign","if","ValidationError","throw","validateErrs","_await","passCxt","passContext","default","this","passSchema","callValidateCode","not","data","parentData","parentDataProperty","errs","vErrors","extendErrors","schemaEnv","$async","Error","result","undefined","scopeValue","ref","code","stringify","schemaType","allowUndefined","length","some","st","Array","isArray","includes","deps","dependencies","kwd","prototype","hasOwnProperty","join","msg","errorsText","logger"],"sources":["C:/Users/Pc/Desktop/RTI 3. god/6. semestar/PIA/Projekat/frontend/node_modules/ajv/dist/compile/validate/keyword.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}